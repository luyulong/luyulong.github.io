<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  
    <link href='//fonts.lug.ustc.edu.cn/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  


<link rel="stylesheet" type="text/css" href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" />

<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="记录生活点滴" />



  <meta name="keywords" content="Hexo,next" />





  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="记录生活点滴">
<meta property="og:type" content="website">
<meta property="og:title" content="yl.lu Blog">
<meta property="og:url" content="http://luyulong.github.io/index.html">
<meta property="og:site_name" content="yl.lu Blog">
<meta property="og:description" content="记录生活点滴">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="yl.lu Blog">
<meta name="twitter:description" content="记录生活点滴">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'always'
  };
</script>



  <title> yl.lu Blog - 记录生活点滴 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">yl.lu Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">day and day</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
            公益404
          </a>
        </li>
      

      
      
    </ul>
  

  
    <div class="site-search">
      
  
  <form class="site-search-form">
    <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
  </form>


<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'GnNsRG1nR57vezMsPQ-W','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2016/09/06/docker入门/" itemprop="url">
                  docker入门
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-09-06T09:16:21+08:00" content="2016-09-06">
              2016-09-06
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/06/docker入门/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/06/docker入门/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>一、介绍<br>1、 Docker的特性：<br>文件系统隔离：每个进程容器运行在一个完全独立的根文件系统里。<br>资源隔离：系统资源，像CPU和内存等可以分配到不同的容器中，使用cgroup。<br>网络隔离：每个进程容器运行在自己的网络空间，虚拟接口和IP地址。<br>日志记录：Docker将会收集和记录每个进程容器的标准流（stdout/stderr/stdin），用于实时检索或批量检索。<br>变更管理：容器文件系统的变更可以提交到新的映像中，并可重复使用以创建更多的容器。无需使用模板或手动配置。<br>交互式shell：Docker可以分配一个虚拟终端并关联到任何容器的标准输入上。</p>
<p>2、docker 应用场景<br>加速本地开发：快速搭建好开发环境和运行环境。<br>自动打包和部署应用。<br>创建轻量级的私有Paas环境。<br>自动化测试和持续集成。<br>创建安全沙盒。</p>
<p>二、环境搭建：<br>Docker对Linux环境有两个要求，一是64位系统，二是内核在3.8以上。 下面以centos 上搭建为例:</p>
<p>docker仓库用来保存我们的images，当我们创建了自己的image之后我们就可以使用push、pull命令从公有或者私有仓库下载、上传镜像；Docker Registry私有服务器用于保存管理我们的私有镜像。</p>
<p>需要注意的是CentOS 6.X与7.0的安装是有一点点不同的，CentOS-6上docker的安装包叫docker-io，并且来源于Fedora epel库，这个仓库维护了大量的没有包含在发行版中的软件，所以先要安装EPEL，而CentOS-7的docker直接包含在官方镜像源的Extras仓库（CentOS-Base.repo下的[extras]节enable=1启用）。前提是都需要联网，<br>centos 6.8 的具体安装启动过程如下。<br>yum -y install docker-io<br>service docker start<br>chkconfig docker on</p>
<p>centos 7 的安装启动过程如下<br>yum -y install docker<br>systemctl start docker.service<br>systemctl enable docker.service</p>
<p>三、基本操作&amp;命令</p>
<p>简单查询：<br>   docker info<br>   docker search imangeName 从长款查询容器。<br>   docker inspect imageName:version  查看镜像设置</p>
<p>镜像相关：<br>docker images 查看所有本地镜像。<br>docker pull NAME[:TAG|@DIGEST]    下载镜像<br>            eg: docker pull centos  等级   docker pull centos:latest<br>docker imi imageId  删除镜像（前提：镜像启动的容器都已经被删除。）<br>本地文件：<a href="https://docs.docker.com/engine/u" target="_blank" rel="external">https://docs.docker.com/engine/u</a> … magesandcontainers/<br>本地镜像的总描述文件<br>撒地方 centos6.8: /var/lib/docker/repositories-devicemapper.json （ 注意centos 6.8 没有var/lib/docker/image/文件夹， 在docker 1.10 后，容器的所有配置文件同意移动到了 /var/lib/docker/image文件夹中）centos7: /var/lib/docker/image/devicemapper/repositories.json</p>
<p>本地单个镜像的文件：<br>centos  /var/lib/docker/graph/{imageid}/<br>           json -保存着关于这个镜像的元数据<br>           layersize – 一个整数，表示layer的大小。<br>           存储： 一个镜像就是的基础是一系列的layers，   一个docker 镜像就是一组制度的layer组成，</p>
<pre><code>docker 1.7之前： docker images --tree  可以查看一个镜像包含的所有layers          1.7之后： dockviz images -d |dog -Tpng -o images.png
</code></pre><p>  容器储存储位置 centos 6.8/7 :<br>由于目Docker支持AUFS，Btrfs，Device mapper，OverlayFS，ZFS五种存储驱动，所有各自存储的位置是不一样的 <a href="http://www.tuicool.com/articles/JrMFN3e" target="_blank" rel="external">http://www.tuicool.com/articles/JrMFN3e</a><br>命令查看 docker image   结构 ：<br>               centos 6.8 &amp;docker1.7:       docker daemon -D -s overlay  -g /varlib/docker  首先会提示内核版本过低<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@ssdpc admin]# docker -d </span><br><span class="line">WARN[0000] You are running linux kernel version 2.6.32-642.1.1.el6.x86_64, which might be unstable running docker. Please upgrade your kernel to 3.10.0. </span><br><span class="line">INFO[0000] Listening for HTTP on unix (/var/run/docker.sock) </span><br><span class="line">INFO[0000] [graphdriver] using prior storage driver "devicemapper" </span><br><span class="line">WARN[0000] Running modprobe bridge nf_nat failed with message: , error: exit status 1 </span><br><span class="line">INFO[0000] Loading containers: start.                   </span><br><span class="line"></span><br><span class="line">INFO[0000] Loading containers: done.                    </span><br><span class="line">INFO[0000] Daemon has completed initialization          </span><br><span class="line">INFO[0000] Docker daemon                                 commit=786b29d/1.7.1 execdriver=native-0.2 graphdriver=devicemapper version=1.7.1</span><br></pre></td></tr></table></figure></p>
<p>centos 6.8 &amp;docker1.8 :    </p>
<p>容器相关:<br>docker ps  :  查询当前启动的容器，   docker ps -a  (所有的包含停止的)<br>docker stop  xxx: 停止容器<br>docker start  containId 可以启动一个已经停止的容器<br>docker rm   xxx:   删除停止的容器<br>ducker run 启动一个容器 ， 参数说明<br>        -d  后台运行<br>        -t -i 合用， 交互模式运行<br>       -net 指定网络， 默认bridge （会使用172段的ip依次分配给启动的docker 容器）， host  模式为共享主机的网络配置和端口。<br>       -p 当net不为host 模式时， 将容器的端口 映射到宿主机器的端口上。<br>       –ip  指定容器的ip<br>        -e 环境变量设置<br>docker cp container:path hostpath  这个命令是从容器内复制文件到指定的路径上</p>
<p>镜像保存1： 导入导出容器为镜像 export &amp; import ：<br>           docker export containId  &gt;mycontain.tar  注意导出只是容器的静态文件快照，docker file 描述将会丢失。<br>           cat mycontain.tar |docker import - tqcommontomcat:0.01   导入发布为本地的一个镜像。<br>镜像保存2：导入导出镜像为镜像 2 save &amp; load：<br>           docker  save imageName:version &gt; save.tar  或者   docker save -o save.tar imageName:version保存镜像，包含layers ，和dockerfile<br>            docker  load &lt; /home/save.tar 或  docker load -i save.tar<br>镜像保存3：   commit ，提交当前容器为一个镜像<br>         docker commit contarinId  imageName:version</p>
<p>docker daemon<br>所谓docker damemon 即为docker server 主进程， centos 6.8 : /etc/init.d/docker start ,  centos 7 :  systemctl start docker.service</p>
<p>Docker 1.10增加了新功能（<a href="http://geek.csdn.net/news/detail/54953），从这个版本以后，用户在Linux上跑Docker时都不必再以root权限运行了。" target="_blank" rel="external">http://geek.csdn.net/news/detail/54953），从这个版本以后，用户在Linux上跑Docker时都不必再以root权限运行了。</a><br>　　1.10之前所有容器都只能在Docker daemon下以root权限运行。<br>　　安全的命名空间. 通过命名空间，Docker 1.10将Docker daemon和容器区别开来，对二者的权限分别加以处理，同时为各个容器分配相应的权限等级。在1.10下，Docker daemon仍然要取得主机的root权限，但容器就可以不用了。<br>传统的容器管理工具 LXC 即将退出 Docker 的舞台，<br>在 Linux 内核版本 3.10+ 上，使用内嵌的 overlay 驱动来完成跨主机的网络互联</p>
<p>在docker 1.10以前： 启动dokcer server 实际执行命令为：docker   -d $other_args<br>    设置dns使用 docker -d –dns 8.8.8.8<br>     设置dns搜索域 docker -d –dns-search example.com<br>      输出调试log   docker -d -D</p>
<p>在docker 1.10 后：   docker daemon $other_args<br>    docker daemon -D -s overlay -g /var/lib/docker</p>
<p>进入容器内部：<br>  docker attach 老方式<br>docker exec -ti   containId  /bin/bash</p>
<p>容器网络<br>docker network  ls 列出所有容器的网络id ,和网络模式</p>
<p>docker network inspect networkId 列出网络的详细信息</p>
<p>docker network connect  –option  containId 为运行中容器创建网络</p>
<p>dockerfile 相关<br>FROM imagename:version   时以每个镜像为基础 layer<br>ENV  key  value 设置环境变量<br>ADD hostFIle  imagePath   把宿主机器上的文件添加的镜像中， 请使用绝对路径<br>WORKDIR  xxx  容器启动时默认工作目录<br>RUN  commond   是指build 过程中随便执行的命令， 例如在镜像中创建文件等。<br>VOLUME  讲宿主本地目录挂载到容器上<br>CMD  设置容器启动的时候执行的命令<br>ENTRYPOINT   container启动时执行的命令，但是一个Dockerfile中只能有一条ENTRYPOINT命令，如果多条，则只执行最后一条ENTRYPOINT没有CMD的可替换特性<br>……</p>
<p>四、example<br>镜像tqtestjava:2.0 制作，tqtestjava:2.0 是一个userauth 和userauthweb的运行环境，<br>  容器启动的功能包括：   1、能够在容器内部自动更新svn代码，2、自动mvn install ,自动启动两个java ，3、容器的端口自动映射。<br>1、容器打包<br>   下载一个基础的centos 镜像，docker pull centos<br>   以交互模式启动centos 容器：  docker run -d -ti  centos /bin/bash，<br>   进入容器bash后，安装yum , net ,  jdk, svn ,maven , svn co 社管代码到 /usr/local/project/zhejiange 下， 编写启动脚本/usr/local/start_zhejiang.sh<br>   （这里需要注意的是我一开始讲许多环境变量设置在/etc/profile 中，其实对docker 来说，这可能是无效的，因为docker 的许多镜像，都市linux 精简版本 ，系统启动也仅仅加载必要的资源），所以需要我们在docke run 是指定环境变量，或者在dockerfile 中指定（固定不变的话）。<br>   提交镜像： docker cmmoit   mycontainId     tqtestjava:1.0</p>
<p>2、 tqtestjava:1.0 虽然有了我们需要自行的环境， 我们也可以以交互模式进入，启动我们的应用，但是如果要让我们的应用在容器启动的时候自动启动应用， 需要 在docker run 命令后面拼接以系列的环境变量， 换需要手动指定docker 启动的时自行的脚本, 工作目录等。<br>例如：<br>docker run -d  –net=host  -ti  -e MAVEN_HOME=/opt/maven  -e JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.101-3.b13.el7_2.x86_64 -e PATH=$PATH:$MAVEN_HOME/bin/:$JAVA_HOME/bin/:/usr/local/project/      tqtestjava:1.0  /usr/local/project/start_zhejiang.sh<br>复制代码</p>
<p>这对使用人员来说不太方面。<br>所以我们编写dockeFile : dockerUseranthTest.txt<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">FROM tqtestjava:1.0</span><br><span class="line">ENV JAVA_HOME /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.101-3.b13.el7_2.x86_64</span><br><span class="line">ENV MAVEN_HOME /opt/maven</span><br><span class="line">ENV PATH $PATH:$MAVEN_HOME/bin/:$JAVA_HOME/bin/:/usr/local/project/</span><br><span class="line">WORKDIR /usr/local/project/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN date;sleep 100;date</span><br><span class="line">RUN echo "============end==="</span><br><span class="line">CMD ["/usr/local/project/start_zhejiang.sh", " start " , "start"]</span><br><span class="line">[root@ssdpc dockerapp]# ^C</span><br><span class="line">[root@ssdpc dockerapp]# ll</span><br><span class="line">total 8</span><br><span class="line">-rw-r--r--. 1 root root 335 Aug 31 15:48 dockerCommonTomcat</span><br><span class="line">-rw-r--r--. 1 root root 340 Aug 31 08:45 dockerUseranthTest</span><br><span class="line">[root@ssdpc dockerapp]# more dockerUseranthTest </span><br><span class="line">FROM tqtestjava:0.04</span><br><span class="line">ENV JAVA_HOME /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.101-3.b13.el7_2.x86_64</span><br><span class="line">ENV MAVEN_HOME /opt/maven</span><br><span class="line">ENV PATH=$PATH:$MAVEN_HOME/bin/:$JAVA_HOME/bin/:/usr/local/project/</span><br><span class="line">WORKDIR /usr/local/project/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN date;sleep 100;date</span><br><span class="line">RUN echo "============end==="</span><br><span class="line">CMD ["/usr/local/project/start_zhejiang.sh", " start " , "start"]</span><br></pre></td></tr></table></figure></p>
<p>然后执行： docker build -f dockerUseranthTest.txt  -t tqtestjave:2.0 .<br>这样我们就新生成了一个 tqtestjave:2.0 镜像。<br>最后执行： docker -d  –net=host  tqtestjave:2.0   就可以实现启动容器时应用自启动了</p>
<p>3、网络选择： 这里我们选择host 模式， 不是说host 模式好，而且线上也不建议使用host模式。  而且因为如果我们选择bridge 模式，需要在路由器上设置一个172段的路由网关，同时固定宿主机器上分配的docker 容器的ip 段。   这适合于有网络经验的人来搞。</p>
<p>五、docker REST API</p>
<p>docker的所有命令可以通过一系列的restful 的API ， 这对生产环境编写漂亮发布，部署脚本十分有效</p>
<p>docker images  可以等级与：<br>echo -e “GET /images/tomcat/json HTTP/1.0\r\n” |nc -U /var/run/docker.sock</p>
<p>docker ps 可以等级与：<br>echo -e “GET /containers/json HTTP/1.0\r\n” |nc -U /var/run/docker.sock</p>
<p>默认情况下 Docker 的守护进程启动会生成一个 socket （/var/run/docker.sock）进程通信文件，而并没有监听端口，只能在本机操作 Docker。如果想在其它地方操作 Docker 主机，就需要让 Docker 主机监听一个端口号，这样可以通过端口号就能实现远程操作。</p>
<p>1、对于手动启动的docker daemon :可以这样配置<br>docker -d -H unix:///var/run/docker.sock -Htcp://0.0.0.0:5678<br>2、ubuntu :<br>  vim /etc/default/docker.io :<br>         DOCKER_OPTS=” -H unix:///var/run/docker.sock” =====修改为====&gt;DOCKER_OPTS=” -H tcp://0.0.0.0:5678 -H unix:///var/run/docker.sock”<br>   service docker.io restart<br>3、Red Hat 7系列<br>     systemctl stop  docker<br>     vim /etc/sysconfig/docker<br>              修改other_args 的值<br>               other_args=” -H tcp://0.0.0.0:5678 -H unix:///var/run/docker.sock”<br>     systemctl start docker </p>
<p>配置验证：<br>docker -H localhost:5678 version</p>
<p>六、相关资源<br><a href="https://github.com/docker" target="_blank" rel="external">https://github.com/docker</a></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2016/07/08/Java-多线程：InheritableThreadLocal-实现原理/" itemprop="url">
                  Java 多线程：InheritableThreadLocal 实现原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-07-08T08:56:04+08:00" content="2016-07-08">
              2016-07-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/08/Java-多线程：InheritableThreadLocal-实现原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/08/Java-多线程：InheritableThreadLocal-实现原理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>介绍 InheritableThreadLocal 之前，假设对 ThreadLocal 已经有了一定的理解，比如基本概念，原理，如果没有，可以参考：Java 多线程：threadlocal关键字。<br>这里再复习下 ThreadLocal 的原理，因为会对 InheritableThreadLocal 的理解 有重大的帮助：<br>每个线程都有一个 ThreadLocalMap 类型的 threadLocals 属性。<br>ThreadLocalMap 类相当于一个Map，key 是 ThreadLocal 本身，value 就是我们的值。<br>当我们通过 threadLocal.set(new Integer(123)); ，我们就会在这个线程中的 threadLocals 属性中放入一个键值对，key 是 这个 threadLocal.set(new Integer(123)); 的 threadlocal，value 就是值。<br>当我们通过 threadlocal.get() 方法的时候，首先会根据这个线程得到这个线程的 threadLocals 属性，然后由于这个属性放的是键值对，我们就可以根据键 threadlocal 拿到值。 注意，这时候这个键 threadlocal 和 我们 set 方法的时候的那个键 threadlocal 是一样的，所以我们能够拿到相同的值。<br>Ps：如果这个原理没搞清楚，那么下文估计有比较难理解，所以建议完完全全搞懂这个原理。<br>InheritableThreadLocal 概念</p>
<p>从上面的介绍我们可以知道，我们其实是根据 Thread.currentThread()，拿到该线程的 threadlocals，从而进一步得到我们之前预先 set 好的值。那么如果我们新开一个线程，这个时候，由于 Thread.currentThread() 已经变了，从而导致获得的 threadlocals 不一样，我们之前并没有在这个新的线程的 threadlocals 中放入值，那么我就再通过 threadlocal.get()方法 是不可能拿到值的。例如如下代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String args[]</span>)</span>&#123;</span><br><span class="line">        threadLocal.<span class="keyword">set</span>(<span class="keyword">new</span> Integer(<span class="number">123</span>));</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"main = "</span> + threadLocal.<span class="keyword">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MyThread</span> <span class="title">extends</span> <span class="title">Thread</span>&#123;</span><br><span class="line">        @<span class="function">Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"MyThread = "</span> + threadLocal.<span class="keyword">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出是：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">main</span> = <span class="number">123</span></span><br><span class="line"><span class="attr">MyThread</span> = null</span><br></pre></td></tr></table></figure>
<p>那么这个时候怎么解决？ InheritableThreadLocal 就可以解决这个问题。 先看一个官方对它的介绍：</p>
<ul>
<li>This class extends <tt>ThreadLocal</tt> to provide inheritance of values</li>
<li>from parent thread to child thread: when a child thread is created, the</li>
<li>child receives initial values for all inheritable thread-local variables</li>
<li>for which the parent has values.  Normally the child’s values will be</li>
<li>identical to the parent’s; however, the child’s value can be made an</li>
<li>arbitrary function of the parent’s by overriding the <tt>childValue</tt></li>
<li>method in this class.<br>也就是说，我们把上面的</li>
</ul>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;<span class="built_in">Integer</span>&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;<span class="built_in">Integer</span>&gt;();</span><br></pre></td></tr></table></figure>
<p>改成</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;<span class="built_in">Integer</span>&gt; threadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;<span class="built_in">Integer</span>&gt;();</span><br></pre></td></tr></table></figure>
<p>再运行，就会有结果：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">main</span> = <span class="number">123</span></span><br><span class="line"><span class="attr">MyThread</span> = <span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>也就是子线程或者说新开的线程拿到了该值。那么，这个究竟是怎么实现的呢，key 都变了，为什么还可以拿到呢？<br>InheritableThreadLocal 原理</p>
<p>我们可以首先可以浏览下 InheritableThreadLocal 类中有什么东西：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal&lt;T&gt;</span> <span class="keyword">extends</span> <span class="title">ThreadLocal&lt;T&gt;</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">T</span> childValue(<span class="type">T</span> parentValue) &#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ThreadLocalMap</span> getMap(<span class="type">Thread</span> t) &#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">    void createMap(<span class="type">Thread</span> t, <span class="type">T</span> firstValue) &#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> <span class="type">ThreadLocalMap</span>(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是重写了3个方法。<br>首先，当我们调用 get 方法的时候，由于子类没有重写，所以我们调用了父类的 get 方法：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">    <span class="type">Thread</span> t = <span class="type">Thread</span>.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != null) &#123;</span><br><span class="line">        <span class="type">ThreadLocalMap</span>.<span class="type">Entry</span> e = map.getEntry(this);</span><br><span class="line">        <span class="keyword">if</span> (e != null) &#123;</span><br><span class="line">            @<span class="type">SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T <span class="literal">result</span> = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会有一个Thread.currentThread() ， getMap(t) 方法，所以就会得到这个线程 threadlocals。 但是，由于子类 InheritableThreadLocal 重写了 getMap()方法，再看上述代码，我们可以看到： 其实不是得到 threadlocals，而是得到 inheritableThreadLocals。 inheritableThreadLocals 之前一直没提及过，其实它也是 Thread 类的一个 ThreadLocalMap 类型的 属性，如下 Thread 类的部分代码：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap <span class="attr">threadLocals</span> = <span class="literal">null</span>;</span><br><span class="line">ThreadLocal.ThreadLocalMap <span class="attr">inheritableThreadLocals</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>那么，这里看 InheritableThreadLocal 重写的方法，感觉 inheritableThreadLocals 和 threadLocals 几乎是一模一样的作用，只是换了个名字而且，那么究竟 为什么在新的 线程中 通过 threadlocal.get() 方法还能得到值呢？<br>这时候要注意 childValue 方法，我们可以看下它的官方说明：</p>
<ul>
<li>Computes the child’s initial value for this inheritable thread-local</li>
<li>variable as a function of the parent’s value at the time the child</li>
<li>thread is created.  This method is called from within the parent</li>
<li>thread before the child is started.<br>这个时候，你明白了，是不是在 创建线程的时候做了手脚，做了一些值的传递，或者这里利用上了 inheritableThreadLocals 之类的。<br>其实，是的：<br>关键在于 Thread thread = new MyThread();<br>关键在于 Thread thread = new MyThread();<br>关键在于 Thread thread = new MyThread();<br>这不是一个简简单单的 new 操作。当我们 new 一个 线程的时候：</li>
</ul>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable <span class="keyword">target</span>, String name,</span><br><span class="line">                      <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">    init(g, <span class="keyword">target</span>, name, stackSize, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="literal">void</span> init(ThreadGroup g, Runnable target, <span class="built_in">String</span> name,</span><br><span class="line">                      long stackSize, AccessControlContext acc) &#123;</span><br><span class="line">     <span class="attr">...</span><span class="attr">...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">parent</span>.inheritableThreadLocals != <span class="built_in">null</span>)</span><br><span class="line">        this.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(<span class="keyword">parent</span>.inheritableThreadLocals);</span><br><span class="line">        <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">        this.stackSize = stackSize;</span><br><span class="line">    <span class="attr">...</span><span class="attr">...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这时候有一句 ‘ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);’ ，然后</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function">ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续跟踪：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ThreadLocalMap(ThreadLocalMap parentMap) &#123;</span><br><span class="line">    Entry[] parentTable = parentMap.table;</span><br><span class="line">    <span class="built_in">int</span> len = parentTable.length;</span><br><span class="line">    setThreshold(len);</span><br><span class="line">    table = <span class="keyword">new</span> Entry[len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = parentTable[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">            ThreadLocal&lt;<span class="keyword">Object</span>&gt; <span class="built_in">key</span> = (ThreadLocal&lt;<span class="keyword">Object</span>&gt;) e.<span class="built_in">get</span>();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">key</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">Object</span> value = <span class="built_in">key</span>.childValue(e.value);</span><br><span class="line">                Entry c = <span class="keyword">new</span> Entry(<span class="built_in">key</span>, value);</span><br><span class="line">                <span class="built_in">int</span> h = <span class="built_in">key</span>.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                    table[h] = c;</span><br><span class="line">                    <span class="built_in">size</span>++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当我们创建一个新的线程的时候X，X线程就会有 ThreadLocalMap 类型的 inheritableThreadLocals ，因为它是 Thread 类的一个属性。</p>
<h2 id="然后"><a href="#然后" class="headerlink" title="然后"></a>然后</h2><p>先得到当前线程存储的这些值，例如 Entry[] parentTable = parentMap.table; 。再通过一个 for 循环，不断的把当前线程的这些值复制到我们新创建的线程X 的inheritableThreadLocals 中。就这样，就ok了。<br>那么这样会有一个什么结果呢？<br>结果就是我们创建的新线程X 的inheritableThreadLocals 变量中已经有了值了。那么我在新的线程X中调用 threadlocal.get()方法，首先会得到新线程X 的 inheritableThreadLocals，然后，再根据threadlocal.get()中的 threadlocal，就能够得到这个值。<br>这样就避免了 新线程中得到的 threadlocals 没有东西。之前就是因为没有东西，所以才拿不到值。<br>所以说 整个 InheritableThreadLocal 的实现原理就是这样的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先要理解 为什么 在 新线程中得不到值，是因为我们其实是根据 Thread.currentThread()，拿到该线程的 threadlocals，从而进一步得到我们之前预先 set 好的值。那么如果我们新开一个线程，这个时候，由于 Thread.currentThread() 已经变了，从而导致获得的 threadlocals 不一样，我们之前并没有在这个新的线程的 threadlocals 中放入值，那么我就再通过 threadlocal.get()方法 是不可能拿到值的。<br>那么解决办法就是 我们在新线程中，要把父线程的 threadlocals 的值 给复制到 新线程中的 threadlocals 中来。这样，我们在新线程中得到的 threadlocals 才会有东西，再通过 threadlocal.get() 中的 threadlocal，就会得到值。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>java concurrency in practice读书笔记—ThreadLocal原理<br>ThreadLocal和synchronized的区别?</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2016/07/08/Java-多线程：CAS-与-AtomicInteger（乐观锁）/" itemprop="url">
                  Java 多线程：CAS 与 AtomicInteger（乐观锁）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-07-08T08:51:33+08:00" content="2016-07-08">
              2016-07-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/08/Java-多线程：CAS-与-AtomicInteger（乐观锁）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/08/Java-多线程：CAS-与-AtomicInteger（乐观锁）/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>Java 多线程：CAS 与 AtomicInteger（乐观锁）</p>
<h6 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h6><p>我们都知道，cpu是时分复用的，也就是把cpu的时间片，分配给不同的thread/process轮流执行，时间片与时间片之间，需要进行cpu切换，也就是会发生进程的切换。切换涉及到清空寄存器，缓存数据。然后重新加载新的thread所需数据。当一个线程被挂起时，加入到阻塞队列，在一定的时间或条件下，在通过notify()，notifyAll()唤醒回来。<br>在某个资源不可用的时候，就将cpu让出，把当前等待线程切换为阻塞状态。等到资源(比如一个共享数据）可用了，那么就将线程唤醒，让他进入runnable状态等待cpu调度。这就是典型的悲观锁的实现。独占锁是一种悲观锁，synchronized就是一种独占锁，它假设最坏的情况，并且只有在确保其它线程不会造成干扰的情况下执行，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。<br>但是，由于在进程挂起和恢复执行过程中存在着很大的开销。当一个线程正在等待锁时，它不能做任何事，所以悲观锁有很大的缺点。举个例子，如果一个线程需要某个资源，但是这个资源的占用时间很短，当线程第一次抢占这个资源时，可能这个资源被占用，如果此时挂起这个线程，可能立刻就发现资源可用，然后又需要花费很长的时间重新抢占锁，时间代价就会非常的高。<br>所以就有了乐观锁的概念，他的核心思路就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。在上面的例子中，某个线程可以不让出cpu,而是一直while循环，如果失败就重试，直到成功为止。所以，当数据争用不严重时，乐观锁效果更好。比如CAS就是一种乐观锁思想的应用。</p>
<h6 id="Java中CAS的实现"><a href="#Java中CAS的实现" class="headerlink" title="Java中CAS的实现"></a>Java中CAS的实现</h6><p>CAS就是Compare and Swap的意思，比较并操作。很多的cpu直接支持CAS指令。CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。<br>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。<br>JDK1.5中引入了底层的支持，在int、long和对象的引用等类型上都公开了CAS的操作，并且JVM把它们编译为底层硬件提供的最有效的方法，在运行CAS的平台上，运行时把它们编译为相应的机器指令。在java.util.concurrent.atomic包下面的所有的原子变量类型中，比如AtomicInteger，都使用了这些底层的JVM支持为数字类型的引用类型提供一种高效的CAS操作。</p>
<h6 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h6><p>在CAS操作中，会出现ABA问题。就是如果V的值先由A变成B，再由B变成A，那么仍然认为是发生了变化，并需要重新执行算法中的步骤。<br>有简单的解决方案：不是更新某个引用的值，而是更新两个值，包括一个引用和一个版本号，即使这个值由A变为B，然后为变为A，版本号也是不同的。<br>AtomicStampedReference和AtomicMarkableReference支持在两个变量上执行原子的条件更新。AtomicStampedReference更新一个“对象-引用”二元组，通过在引用上加上“版本号”，从而避免ABA问题，AtomicMarkableReference将更新一个“对象引用-布尔值”的二元组。</p>
<h6 id="AtomicInteger的实现"><a href="#AtomicInteger的实现" class="headerlink" title="AtomicInteger的实现"></a>AtomicInteger的实现</h6><p>AtomicInteger 是一个支持原子操作的 Integer 类，就是保证对AtomicInteger类型变量的增加和减少操作是原子性的，不会出现多个线程下的数据不一致问题。如果不使用 AtomicInteger，要实现一个按顺序获取的 ID，就必须在每次获取时进行加锁操作，以避免出现并发时获取到同样的 ID 的现象。<br>接下来通过源代码来看AtomicInteger具体是如何实现的原子操作。首先看incrementAndGet() 方法，下面是具体的代码：</p>
<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final <span class="keyword">int</span> incrementAndGet() &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="comment">;;) &#123;  </span></span><br><span class="line">            <span class="keyword">int</span> current = get()<span class="comment">;  </span></span><br><span class="line">            <span class="keyword">int</span> <span class="keyword">next</span> = current + <span class="number">1</span><span class="comment">;  </span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, <span class="keyword">next</span>))  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">next</span><span class="comment">;  </span></span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过源码，可以知道，这个方法的做法为先获取到当前的 value 属性值，然后将 value 加 1，赋值给一个局部的 next 变量，然而，这两步都是非线程安全的，但是内部有一个死循环，不断去做compareAndSet操作，直到成功为止，也就是修改的根本在compareAndSet方法里面，compareAndSet()方法的代码如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;  </span><br><span class="line">        <span class="function"><span class="keyword">return</span> unsafe.<span class="title">compareAndSwapInt</span><span class="params">(<span class="keyword">this</span>, valueOffset, expect, update)</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>compareAndSet()方法调用的compareAndSwapInt()方法的声明如下，是一个native方法: publicfinal native boolean compareAndSwapInt(Object var1, long var2, int var4, intvar5);<br>compareAndSet 传入的为执行方法时获取到的 value 属性值，next 为加 1 后的值， compareAndSet所做的为调用 Sun 的 UnSafe 的 compareAndSwapInt 方法来完成，此方法为 native 方法，compareAndSwapInt 基于的是CPU 的 CAS指令来实现的。所以基于 CAS 的操作可认为是无阻塞的，一个线程的失败或挂起不会引起其它线程也失败或挂起。并且由于 CAS 操作是 CPU 原语，所以性能比较好。<br>类似的，还有decrementAndGet()方法。它和incrementAndGet()的区别是将 value 减 1，赋值给next 变量。<br>AtomicInteger中还有getAndIncrement() 和getAndDecrement() 方法，他们的实现原理和上面的两个方法完全相同，区别是返回值不同，前两个方法返回的是改变之后的值，即next。而这两个方法返回的是改变之前的值，即current。还有很多的其他方法，就不列举了。<br>转载<br><strong>转载</strong></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2016/07/08/Java-多线程：线程池实现原理/" itemprop="url">
                  Java 多线程：线程池实现原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-07-08T08:33:49+08:00" content="2016-07-08">
              2016-07-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/08/Java-多线程：线程池实现原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/08/Java-多线程：线程池实现原理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p><strong>前言</strong></p>
<p>我们都知道，所谓线程池，那么就是相当于有一个池子，线程就放在这个池子中进行重复利用，能够减去了线程的创建和销毁所带来的代价。但是这样并不能很好的解释线程池的原理，下面从代码的角度分析一下线程池的实现。</p>
<p><strong>线程池的相关类</strong></p>
<p>对于原理，在 Java 中，有几个接口，类 值得我们关注：</p>
<p><strong>Executor</strong><br><strong>ExecutorService</strong><br><strong>AbstractExecutorService</strong><br><strong>ThreadPoolExecutor</strong><br><strong>Executor</strong></p>
<p><pre><code><br>public interface Executor {<br>    void execute(Runnable command);<br>}<br></code></pre><br>Executor 接口只有一个 方法，execute，并且需要 传入一个 Runnable 类型的参数。那么它的作用自然是 具体的执行参数传入的任务。</p>
<p><strong>ExecutorService</strong></p>
<p><pre><code><br>public interface ExecutorService extends Executor {</code></pre></p>
<pre><code>void shutdown();

List&lt;Runnable&gt; shutdownNow();

boolean isShutdown();

&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);

&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);

Future&lt;?&gt; submit(Runnable task);

&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
    throws InterruptedException;
......
</code></pre><p>}<br><br>ExecutorService 接口继承了 Executor，并且提供了一些其他的方法，比如说：</p>
<p>shutdownNow ： 关闭线程池，返回放入了线程池，但是还没开始执行的线程。<br>submit ： 执行的任务 允许拥有返回值。<br>invokeAll ： 运行把任务放进集合中，进行批量的执行，并且能有返回值<br>这三个方法也可以说是这个接口重点扩展的方法。</p>
<p>Ps：execute 和 submit 区别：</p>
<p>submit 有返回值，execute 没有返回值。 所以说可以根据任务有无返回值选择对应的方法。<br>submit 方便异常的处理。 如果任务可能会抛出异常，而且希望外面的调用者能够感知这些异常，那么就需要调用 submit 方法，通过捕获 Future.get 抛出的异常。<br>AbstractExecutorService</p>
<p>AbstractExecutorService 是一个抽象类，主要完成了 对 submit 方法，invokeAll 方法 的实现。 但是其实它的内部还是调用了 execute 方法，例如：</p>
<p><pre><code><br>public Future&lt;?&gt; submit(Runnable task) {<br>    if (task == null) throw new NullPointerException();<br>        RunnableFuture<void> ftask = newTaskFor(task, null);<br>        execute(ftask);<br>        return ftask;<br>    }<br></void></code></pre><br><strong>ThreadPoolExecutor</strong></p>
<p>ThreadPoolExecutor 继承了 AbstractExecutorService，并且实现了最重要的 execute 方法，是我们主要需要研究的类。另外，整个线程池是如何实现的呢？<br>在该类中，有两个成员变量 非常的重要：</p>
<p><pre><code><br>private final HashSet<worker> workers = new HashSet<worker>();<br>private final BlockingQueue<runnable> workQueue;<br></runnable></worker></worker></code></pre><br>对于 workers 变量，主要存在了线程对象 Worker，Worker 实现了 Runnable 接口。而对于 workQueue 变量，主要存放了需要执行的任务。 这样其实可以猜到， 整个线程池的实现原理应该是 workQueue 中不断的取出需要执行的任务，放在 workers 中进行处理。</p>
<p>另外，当线程池中的线程用完了之后，多余的任务会等待，那么这个等待的过程是 怎么实现的呢？ 其实如果熟悉 BlockingQueue，那么就会马上知道，是利用了 BlockingQueue 的take 方法进行处理。</p>
<p>下面具体代码分析：</p>
<p><pre><code><br>   public void execute(Runnable command) {<br>        ……<br>        if (workerCountOf(c) &lt; corePoolSize) {<br>            if (addWorker(command, true))<br>                return;<br>            c = ctl.get();<br>        }<br>        if (isRunning(c) &amp;&amp; workQueue.offer(command)) {<br>            int recheck = ctl.get();<br>            if (! isRunning(recheck) &amp;&amp; remove(command))<br>                reject(command);<br>            else if (workerCountOf(recheck) == 0)<br>                addWorker(null, false);<br>        }<br>        ……<br>    }<br></code></pre><br>首先，这里需要先理解两个概念。我们在创建线程池的时候，通常会指定两个变量，一个是maximumPoolSize，另外一个是 corePoolSize。</p>
<p>对于 maximumPoolSize：指的是 线程池中最多允许有多少个线程。<br>对于 corePoolSize： 指的是线程池中正在运行的线程。<br>在 线程池中，有这样的设定，我们加入一个任务进行执行，</p>
<p>如果现在线程池中正在运行的线程数量大于 corePoolSize 指定的值而 小于maximumPoolSize 指定的值，那么就会创建一个线程对该任务进行执行，一旦一个线程被创建运行。<br>如果线程池中的线程数量大于corePoolSize，那么这个任务执行完毕后，该线程会被回收；如果 小于corePoolSize，那么该线程即使空闲，也不会被回收。下个任务过来，那么就使用这个空闲线程。<br>对于上述代码，首先有：</p>
<p>if (workerCountOf(c) &lt; corePoolSize)</p>
<p>也就是说，判断现在的线程数量是否小于corePoolSize，如果小于，那么就创建一个线程执行该任务，也就是执行</p>
<p>addWorker(command, true)</p>
<p>如果大于，那么就把该任务放进队列当中，即</p>
<p>workQueue.offer(command)</p>
<p>那么，addWorker 是干什么的呢？</p>
<p><pre><code><br>private boolean addWorker(Runnable firstTask, boolean core) {<br>    boolean workerStarted = false;<br>    boolean workerAdded = false;<br>    Worker w = null;<br>    try {<br>        w = new Worker(firstTask);<br>        final Thread t = w.thread;<br>        if (t != null) {<br>            final ReentrantLock mainLock = this.mainLock;<br>            mainLock.lock();<br>            try {<br>                int rs = runStateOf(ctl.get());</code></pre></p>
<pre><code>            if (rs &lt; SHUTDOWN ||
                (rs == SHUTDOWN &amp;&amp; firstTask == null)) {
                if (t.isAlive()) // precheck that t is startable
                    throw new IllegalThreadStateException();
                    workers.add(w);
                    int s = workers.size();
                    if (s &gt; largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
         ......
}
</code></pre><p><br>在这里可以看到一些关键代码，例如 w = new Worker(firstTask)， 以及 workers.add(w); 从这里 我们就可以看到，创建 线程对象 并且加入到 线程 队列中。但是，我们现在还没有看到具体是怎么执行任务的，继续追踪 w = new Worker(firstTask)，如下代码：</p>
<p><pre><code><br>private final class Worker<br>        extends AbstractQueuedSynchronizer<br>        implements Runnable<br>    {<br>        ……</code></pre></p>
<pre><code>final Thread thread;

Runnable firstTask;
Worker(Runnable firstTask) {
    setState(-1); // inhibit interrupts until runWorker
    this.firstTask = firstTask;
    this.thread = getThreadFactory().newThread(this);
}
public void run() {
    runWorker(this);
}
......
</code></pre><p><br>对于 runWorker 方法：</p>
<p><pre><code><br>final void runWorker(Worker w) {<br>        Thread wt = Thread.currentThread();<br>        Runnable task = w.firstTask;<br>        w.firstTask = null;<br>        w.unlock(); // allow interrupts<br>        boolean completedAbruptly = true;<br>        try {<br>            while (task != null || (task = getTask()) != null) {<br>                w.lock();<br>                if ((runStateAtLeast(ctl.get(), STOP) ||<br>                     (Thread.interrupted() &amp;&amp;<br>                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                    !wt.isInterrupted())<br>                    wt.interrupt();<br>                try {<br>                    beforeExecute(wt, task);<br>                    Throwable thrown = null;<br>                    try {<br>                        task.run();<br>                    } catch (RuntimeException x) {<br>                        thrown = x; throw x;<br>                    } catch (Error x) {<br>                        thrown = x; throw x;<br>                    } catch (Throwable x) {<br>                        thrown = x; throw new Error(x);<br>                    } finally {<br>                        afterExecute(task, thrown);<br>                    }<br>                }<br>                ……<br>    }<br>    </code></pre><br>在这段代码中，就有很多关键的信息，比如说，Runnable task = w.firstTask;如果为空，那么就 执行 task = getTask()，如果不为空，那么就 进行 task.run(); 调用其方法，这里也就是具体的执行的任务。</p>
<p>现在知道了是怎么样执行具体的任务，那么假如任务的数量 大于 线程池的数量，那么是怎么实现等待的呢，这里就需要看到getTask() 的具体实现了，如下：</p>
<p><pre><code><br>private Runnable getTask() {<br>        for (;;) {<br>           ……<br>            try {<br>                Runnable r = timed ?<br>                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                    workQueue.take();<br>                if (r != null)<br>                    return r;<br>                timedOut = true;<br>            } catch (InterruptedException retry) {<br>                timedOut = false;<br>            }<br>        }<br>    }<br></code></pre><br>这里可以看到， 一个 for 死循环，以及</p>
<p><pre><code><br>Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();<br></code></pre><br>而 workQueue 是 BlockingQueue 类型，也就是带有阻塞的功能。</p>
<p>这就是 线程如何等待执行的。</p>
<p><strong>总结</strong></p>
<p>现在就可以知道，大致的线程池实现原理：</p>
<p>首先，各自存放线程和任务，其中，任务带有阻塞。</p>
<p><pre><code><br>private final HashSet<worker> workers = new HashSet<worker>();<br>private final BlockingQueue<runnable> workQueue;<br></runnable></worker></worker></code></pre><br>然后，在 execute 方法中 进行 addWorker(command，true)，也就是创建一个线程，把任务放进去执行；或者是直接把任务放入到任务队列中。</p>
<p>接着 如果是 addWorker，那么就会 new Worker(task) -》调用其中 run() 方法，在Worker 的run() 方法中，调用 runWorker(this); 方法 -》在该方法中就会具体执行我们的任务 task.run(); 同时这个 runWorker方法相当于是个死循环，正常情况下就会一直取出 任务队列中的任务来执行，这就保证了线程 不会销毁。</p>
<p>所以，这也是为什么常说的线程池可以避免线程的频繁创建和 销毁带来的性能消耗。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2016/07/01/Linux中查找命令总结/" itemprop="url">
                  Linux中查找命令总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-07-01T08:41:34+08:00" content="2016-07-01">
              2016-07-01
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/01/Linux中查找命令总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/01/Linux中查找命令总结/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>一 find<br>find是最常使用和最强大的查找命令，可以找到任何想查找找的文件<br>用法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find &lt;指定目录&gt; <span class="xml"><span class="tag">&lt;<span class="name">指定条件</span>&gt;</span> <span class="tag">&lt;<span class="name">指定动作</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果不加参数，默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件）<br>实例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find /home -name <span class="string">'a*'</span></span><br></pre></td></tr></table></figure></p>
<p>搜索home目录（含子目录）中所有文件名以a开头的文件<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find /home -name <span class="string">'a*'</span> -ls</span><br></pre></td></tr></table></figure></p>
<p>搜索home目录（含子目录）中所有文件名以a开头的文件并显示它们的详细信息。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find /home -type f -mmin <span class="number">-10</span></span><br></pre></td></tr></table></figure></p>
<p>搜索home目录中所有过去10分钟中更新过的普通文件,如果不加-type f参数，则搜索普通文件+特殊文件+目录。</p>
<p>二  locate<br>locate命令实质上是”find -name”的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。<br>实例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ locate /etc/sh</span><br></pre></td></tr></table></figure></p>
<p>搜索etc目录下所有以sh开头的文件<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ locate ~<span class="regexp">/m</span></span><br></pre></td></tr></table></figure></p>
<p>搜索home录下，所有以m开头的文件。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ locate -i ~<span class="regexp">/m</span></span><br></pre></td></tr></table></figure></p>
<p>搜索用户主目录下，所有以m开头的文件，并且忽略大小写</p>
<p>三 whereis<br>whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s），如果省略参数则返回所有信息<br>实例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ whereis grep</span><br></pre></td></tr></table></figure></p>
<p>四 which<br>which命令是在PATH变量指定的路径中搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令就可以看到某个系统命令是否存在以及执行的到底是哪一个位置的命令<br>实例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ which grep</span><br></pre></td></tr></table></figure></p>
<p>五 type<br>type命令其实不能算查找命令，它是用来查看某个命令是由shell自带的还是由shell外部的独立二进制文件提供的，如果一个命令是外部命令，使用-p参数会显示该命令的路径，相当于which命令<br>实例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ type cd</span><br></pre></td></tr></table></figure></p>
<p>输出 “cd 是 shell 内建”<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ type grep</span><br></pre></td></tr></table></figure></p>
<p>输出 “grep 是 `grep –color=auto’ 的别名”<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ type -p grep</span><br></pre></td></tr></table></figure></p>
<p>加上-p参数后就相当于which命令</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2016/06/27/centos-linux查看memcache运行状况/" itemprop="url">
                  centos linux查看memcache运行状况
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-06-27T16:07:36+08:00" content="2016-06-27">
              2016-06-27
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/27/centos-linux查看memcache运行状况/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/27/centos-linux查看memcache运行状况/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>Memcache<br>Memcache是danga.com的一个开源项目，它是一个高性能的分布式的内存对象缓存系统，通过在内存里维护一个统一的巨大的Hash表，能够用来存储各种格式的数据。<br>查看当前的memcache连接数：</p>
<p>[root@mem1 ~]# netstat -n | grep :11211 | wc -l<br>15752</p>
<p>查看默认允许的连接数：<br>[root@mem1 ~]# cat /etc/rc.local </p>
<p>#!/bin/sh<br>#</p>
<h1 id="This-script-will-be-executed-after-all-the-other-init-scripts"><a href="#This-script-will-be-executed-after-all-the-other-init-scripts" class="headerlink" title="This script will be executed after all the other init scripts."></a>This script will be executed <em>after</em> all the other init scripts.</h1><h1 id="You-can-put-your-own-initialization-stuff-in-here-if-you-don’t"><a href="#You-can-put-your-own-initialization-stuff-in-here-if-you-don’t" class="headerlink" title="You can put your own initialization stuff in here if you don’t"></a>You can put your own initialization stuff in here if you don’t</h1><h1 id="want-to-do-the-full-Sys-V-style-init-stuff"><a href="#want-to-do-the-full-Sys-V-style-init-stuff" class="headerlink" title="want to do the full Sys V style init stuff."></a>want to do the full Sys V style init stuff.</h1><p>touch /var/lock/subsys/local<br>/usr/local/bin/memcached -d -m 15360 -u root -l 172.20.1.54 -p 11211 -c 40960<br>/usr/local/bin/memcached -d -m 512 -u root -l 172.20.1.54 -p 11212 -c 10000<br>这里设置的11211端口默认连接数是40960</p>
<p>在网络上查到资料， Memcache也有自己的查看工具：<br>如何查看memcache服务器端版本:  ./memcached  -h<br>memcache的运行状态可以方便的用 stats 命令显示。</p>
<p><img src="/uploads/1467012497.png" alt="Paste_Image.png"></p>
<p>首先用telnet 127.0.0.1 11211这样的命令连接上memcache，然后直接输入stats就可以得到当前memcache的状态。<br>这些状态的说明如下：<br>pid    memcache服务器的进程ID<br>uptime    服务器已经运行的秒数<br>time    服务器当前的unix时间戳<br>version    memcache版本<br>pointer_size    当前操作系统的指针大小（32位系统一般是32bit）<br>rusage_user    进程的累计用户时间<br>rusage_system    进程的累计系统时间<br>curr_items    服务器当前存储的items数量<br>total_items    从服务器启动以后存储的items总数量<br>bytes    当前服务器存储items占用的字节数<br>curr_connections    当前打开着的连接数<br>total_connections    从服务器启动以后曾经打开过的连接数<br>connection_structures    服务器分配的连接构造数<br>cmd_get    get命令（获取）总请求次数<br>cmd_set    set命令（保存）总请求次数<br>get_hits    总命中次数<br>get_misses    总未命中次数<br>evictions    为获取空闲内存而删除的items数（分配给memcache的空间用满后需要删除旧的items来得到空间分配给新的items）<br>bytes_read    总读取字节数（请求字节数）<br>bytes_written    总发送字节数（结果字节数）<br>limit_maxbytes    分配给memcache的内存大小（字节）<br>threads    当前线程数</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2016/06/27/微服务、SOA-和-API对比与分析/" itemprop="url">
                  微服务、SOA 和 API对比与分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-06-27T14:56:34+08:00" content="2016-06-27">
              2016-06-27
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/27/微服务、SOA-和-API对比与分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/27/微服务、SOA-和-API对比与分析/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p><strong>1 简介</strong></p>
<p>在对比微服务架构和面向服务的架构（SOA）时，几乎不可能在它们彼此的关系上达成一致意见。如果应用程序编程接口（API） 再加入混战，就会让理解它们的差异变得更加困难。一些人可能会说这些概念完全不同，它们各自解决自己的一组问题，而且拥有独特的应用范围。其他人可能更宽厚，认为它们实现了类似的目标，并且具有相同的工作原理。<br>他们可能还会说微服务架构是一种 “细粒度的 SOA” 或 “SOA 的恰当应用”。</p>
<p><strong>2 一种过于简单的观点</strong></p>
<p>难以对比 SOA 和微服务的原因在于，它们的定义留有很大的解释空间。如果您仅拥有这两个概念的表面知识，可能会觉得它们很相似。一些关键方面（比如组件化、解耦和标准化通信协议）描述了最近几十年的大部分软件举措，所以我们需要进行更深入地分析。</p>
<p>考虑以下简单定义：</p>
<p>微服务架构是一种构造应用程序的替代性方法。应用程序被分解为更小、完全独立的组件，这使得它们拥有更高的敏捷性、可伸缩性和可用性。<br>SOA将应用程序的功能公开为更容易访问的服务接口，使得在下一代应用程序中使用它们的数据和逻辑变得更容易。<br>如下图演示了这些定义。SOA 似乎拥有 企业范围，应用程序在该范围内彼此通信。SOA 通过应用程序之间的标准化接口来公开服务。微服务架构似乎拥有 应用程序范围，仅关注一个应用程序内的结构和组件。</p>
<p><img src="/uploads/wfwysoa.png" alt="Paste_Image.png"></p>
<p>这些 SOA 和微服务的定义过于简单。事实上，它们之间的关系要复杂得多。</p>
<p><strong>3 SOA 举措的分裂</strong></p>
<p>在更详细地分析 SOA 时，您可以看到它的原始意图不仅仅是将接口公开为 SOAP Web 服务。SOA 基于两种观点，它们满足了不同的需求。</p>
<p><strong>3.1 集成引导的技术元素</strong></p>
<p>第一种观点包括需要深入集成到现有系统的复杂的专用数据格式、协议和传输机制中。然后需要使用标准化的机制（比如 SOAP/HTTP 或最近的 JSON/HTTP）来公开它们，使它们更易于在新应用程序中重用。这种观点如下图的左侧所示。此观点的部分或全部通常被称为 企业服务总线 (ESB) 模式。但是，这个词被随意使用，以至于失去了它原有的意义。</p>
<p>执行深入集成（集成中心或适配器）和以标准化方式（公开网关）将这些集成公开为服务或 API 的需求是必不可少的。这个方面与集成挑战密切相关，与应用程序设计也有一点关联。因此它似乎与微服务应用程序架构没什么关系。</p>
<p><strong>3.2 业务引导的功能元素</strong></p>
<p>第二种观点来自业务角度。关注点是：当前系统上的接口很大程度上没有什么意义。它们对业务没有意义，它们没有提供下一代应用程序所需的东西。它们的粒度可能太细了，公开了系统内太多的复杂数据模型。所需的数据可能分散在多个系统中。数据模型可能不同于业务部门使用的术语。</p>
<p>该需求要求重构功能，以便公开一些业务人员可切实构建到未来解决方案中的东西。这种重构要求创建新的应用程序，将跨现有的记录系统的请求绑定在一起。在 SOA 参考架构中，这些应用程序通常称为 服务组件（如下图的右侧）。这种观点表达了与应用程序设计（进而与微服务架构）和功能分解为单独组件的过程的关系。</p>
<p><img src="/uploads/soajsgn.png" alt="Paste_Image.png"></p>
<p><strong>3.3 混合这些观点的挑战</strong></p>
<p>组织在哪种观点具有更大挑战的看法上存在差异。对于某些组织，他们最大的挑战是集成的多样性和复杂性。对于其他组织，重构和重新布局来实现正确的业务功能是主要的挑战。上图显示了依据您认为哪种挑战占主导，对这个问题的看法有何不同。</p>
<p>对许多组织而言，挑战在于两种观点的混合让人感到很痛苦。痛苦的原因是很难将两种观点合并到单个行动过程中。集成工具不是执行业务逻辑的正确位置。相反地，您不希望您的业务应用程序充斥着技术集成问题。</p>
<p>大多数 SOA 程序的目标都是实现功能方面。它们想获得能够轻松访问的、可用来更有效地构建新应用程序的业务相关服务。但是，许多组织耗尽了精力，或者更常见的是预算不足，而技术集成难题仍未解决。在大型企业中，SOA 通常被认为是失败的。这种想法可能是对的，因为它们未能提供最终的业务价值，尽管付出了巨大努力来改进记录系统的可访问性。但是，在较小的公司（或大型公司中更受限的环境）中，SOA 常常声称真正取得了业务成功，因为它们可快速克服集成问题，并将此转变为功能收益。</p>
<p>这两种 SOA 观点使得与微服务的对比变得很困难。</p>
<p><strong>4 API 与 SOA 公开的服务的对比</strong></p>
<p>API 通常代表着低级编程代码接口。在最近几年，这个词被再次挪用，用来表示通过 HTTP 提供的简单接口。通常它等同于 REST 接口，这些接口使用 JSON 数据格式（有时为 XML）来提供数据，使用 HTTP 动词 PUT、GET、POST 和 DELETE 来描述创建、读取、更新和删除操作。与早期 SOA 中更流行的基于 SOAP 的 Web 服务标准相比，这些协议和数据格式在使用上更加简单。另外，它们更适合 JavaScript 等在创建 API 请求时常用的语言。</p>
<p>但是，SOA Web 服务与 API 之间的区别不是由协议和数据格式来定义的，因为二者没有一致地使用它们。区别在于 API 和 SOA 服务背后的意图。一个关键区别是它们的经济学原理。</p>
<p><strong>4.1 可重用的 SOA</strong></p>
<p>在 SOA 程序中，公开服务旨在公开每个业务功能，以便服务可得到尽可能多的重用。这样，每个新项目就不需要经历再次与后端系统执行集成的痛苦。典型的用户是尝试将全新的用户界面放在旧记录系统上的内部应用程序。在这样做时，集成非常困难，而且会花费很大一部分的 IT 项目预算。如果可以通过可重用的接口公开公司的所有核心功能，就可以大大削减项目成本。SOA 旨在节省成本，而不是创造新收入。</p>
<p>API 拥有不同的出发点，它假设集成已被简化。这种简化是通过早期的一项 SOA 举措或通过升级后端系统提供更容易使用的现代接口来实现的。新的挑战是为潜在的用户设计一个有吸引力的接口。API 是为可能使用它们的上下文而设计的。例如，它们非常适合提供一种特定类型的移动应用程序所需的数据。</p>
<p><strong>4.2 API 管理的黎明</strong></p>
<p>随着智能电话使用量增长，API 的受欢迎程度也在迅速增长。智能电话运行着丰富的客户端应用程序，创造了一种颠覆性的新业务渠道。因此，应用程序开发人员需要简单地访问后端功能和数据；他们需要 API。API 变成一种畅销的产品，API 提供者为吸引开发人员的注意而展开激烈的竞争。API 的关注点不是 SOA 所关注的重用和成本节省。它的关注点是可使用性以及参与 API 经济中的竞争。API 是一种畅销产品。</p>
<p>与 SOA 服务相比，这一动态变化改变了对 API 的技术需求。API 需要复杂的门户，以便开发人员能够发现和试验 API。它们还需要一些机制来供开发人员注册使用和付费购买 API。API 提供者需要能够设置支付计划来适应各种 API 使用率。因为 API 是公开的，所以公开网关需要强大的安全功能。所有这些特性都需要是自助服务，而且最重要的是简单。此变化引入了一种现在称为 API 管理的全新 IT 功能。</p>
<p>为此，API 的关注点是作为某种向外部用户公开的功能；API 与内部 SOA 服务之间的分界线已变得很明确。随着 API 管理技术日渐成熟，API 已带来了诸如易用性和自我管理等收益。结果，许多公司现在还希望使用 API 技术和协议来公开公司内部的服务，如下图所示。SOA Web 服务和 API 之间的界线现在已经变得有些模糊，而且几乎无关紧要。它们在起源、向哪些用户公开和使用的数据模型上不同，但许多 SOA “服务” 也可以描述为内部 API。</p>
<p><img src="/uploads/API.png" alt="Paste_Image.png"><br>如今，API 这个词通常用于指代任何通过 REST (HTTP/JSON) 或 Web 服务（SOAP/HTTP） 公开的接口。API 通常按其范围进行分类，比如公共 API 或企业 API。维持 SOA 举措的企业有时会为内部、企业级 API 保留 “服务” 这个词。</p>
<p>API 这个词表示 SOA 的 “服务公开” 方面的一次进化。它使用更简单的协议，更加精于公开本身，包括开发人员门户、策略控制和自我管理。</p>
<p><strong>5 微服务：一种替代性架构</strong></p>
<p>在考虑对比微服务和 SOA 之前，需要理解微服务架构的含义。从基本角度讲，微服务是构建 应用程序的替代性架构。它们提供了更好的方法来解耦应用程序边界 内的组件。事实上，如果将微服务称为 “微型组件”，它们的实际性质会更加明确。</p>
<p>应用程序的边界保持相同。如下图所示，尽管应用程序在内部被分解为不同的微服务组件，但从外部来看，应用程序仍是相同的。基于微服务的应用程序公开的 API 的数量和粒度不应与将 API 构建为孤立应用程序有任何不同。微服务中的第一个词“微型” 表示内部组件的粒度，而不是公开的接口的粒度。</p>
<p><img src="/uploads/wfwapi.png" alt="Paste_Image.png"></p>
<p>在应用程序内从逻辑上分离组件不是一个新概念。多年以来，大量不同的技术被开发出来，用于实现整个应用程序的各部分的干净分离。应用服务器可在其内部长期运行多个应用程序组件，如下图中的中图所示。微服务更进一步，在这些应用程序组件之间进行了绝对隔离。它们变成网络上单独运行的流程，如下图中的右侧所示。为了实现解耦，您还应分割您的数据模型来与微服务保持一致。</p>
<p><img src="/uploads/dydwfw.png" alt="Paste_Image.png"></p>
<p><strong>6 微服务的优势</strong></p>
<p>完全独立的微服务组件有助于实现完全自主的所有权，带来以下优势：</p>
<p>敏捷性和生产力：开发微服务的团队可以完全理解代码库。他们可以在快得多的周期中与其他组件独立地构建、部署和测试代码库。因为微服务组件只是网络上的另一个组件，所以您可以采用最适合所需功能的语言或框架来编写它，并采用最合适的持久性机制。这种方法可显著减少要编写的代码量，使维护得到显著简化。它可以确保团队能够根据需要采用新技术或现有技术的新版本，而不是等待应用程序域的剩余部分跟上节奏。对于微服务粒度的定义，微服务组件应足够简单，以便在必要时在其下一次迭代中重写。<br>可伸缩性：微服务开发团队可以在运行时与其他组件独立地扩展微服务组件，实现资源的高效使用和对工作负载变化的快速反应。从理论上讲，一个组件的工作负载可以转移到对任务最合适的基础架构上。它还可以与剩余组件独立地重新放置，以便充分利用网络位置。精心编写的微服务提供了非凡的按需可伸缩性，这一领域的早期创新者和采用者已证明这一点。这些微服务也得到了最佳布置，以便充分利用弹性功能，以富有成本效益的方式访问大量资源的原生云环境。<br>恢复能力：独立的运行时可以立即提供与其他组件中的故障独立的恢复能力。借助小心地解耦的设计，比如避免同步依赖关系和使用断路器模式，可以编写每个微服务组件来满足自己的可用性需求，而不是在整个应用程序域中引入这些需求。容器等技术和轻量型运行时使微服务组件能够快速且独立地失败，而不是让所有不相关的功能区域都失效。同样地，它们是以一种高度无状态的方式编写的，以便可以立即重新分布工作负载并几乎同时地调出新运行时。<br>这些优势的示例是组织转而使用微服务的一些最常见的原因。</p>
<p><strong>7 选择微服务时要考虑的关键因素</strong></p>
<p>在决定是否将应用程序编写为微服务时，必须理解以下因素，以确保您的组织准备好处理它们：</p>
<p>新技术模式。微服务是一种完全不同的应用程序构建方法。因为它们在网络上，所以它们需要网络上的一组全新的组件。一些支持技术已经存在，包括服务发现、工作负载编排、容器管理和日志框架。但是，您必须将它们放入一个紧密结合的集合中，这需要大量实验、技能和经验。您必须确定满足您的需求的完美的微服务设置的构成要素，它们可能与其他企业的微服务不同。<br>应用程序适合性。微服务并不适合每个应用程序。目前微服务社区中的一种悖论是，让新的、相对简单的、具有高度凝聚性数据模型的应用程序采用微服务的概念，这样做不会获得任何优势。另外，将一个复杂的现有应用程序重构到微服务架构中是一项繁重的工作。如果不是在旧版或新式应用程序上，您会何时使用微服务？一种 建议是，在以传统方式编写的应用程序达到复杂性的拐点之前，不要使用微服务。但是，要让此方法发挥作用，则需要从一开始就编写一个适当构建的应用程序，并选择在正确的时刻执行过渡。<br>不同的设计范例。微服务应用程序架构需要不同的设计方法。要从微服务方法获得最佳结果，您可能需要：<br>接受最终的一致性模型，而不是您所习惯的事务性交互。<br>理解如何处理没有中央操作数据存储的事件源应用程序。<br>您还需要：</p>
<p>如果需要利用重要的快速可伸缩性优势，请确保您的应用程序逻辑是无状态的。<br>如果将您自己与下游组件分离，则需要熟悉异步通信的细微的潜在副作用。<br>理解实现断路器模式的逻辑后果。<br>认识到 HTTP/JSON 通信相比于进程中通信的错误处理限制。<br>考虑链式交互中的网络延迟。<br>DevOps 成熟性。微服务需要一种成熟的交付能力。持续集成、部署和全自动测试都必不可少。编写代码的开发人员必须负责代码的生产部署。构建和部署链需要重大更改，以便为微服务环境提供正确的关注点分离。</p>
<p><strong>8 微服务如何融入到 SOA 环境和集成挑战中</strong></p>
<p>如果我们 SOA 的心理模式注重集成方面，那么微服务是完全分离的。它是编写集成架构尝试连接的应用程序的一种替代方法，如图 1所示。</p>
<p>但是，如果我们的 SOA 的心理模式注重将应用程序重新布局为对业务更有意义的 “服务组件”，图 2 中的右侧显示的服务组件可能看起来更像微服务组件。微服务架构现在可视为 SOA 的一次进化。为了演示这一点，让我们对比一下两个极端。</p>
<p>首先，考虑一家新的创业公司，该公司对一种完全在线的产品（比如社交媒体或交易）有一种新想法。因为它最初没有现有的架构可用，所以该公司必须创建一套新应用程序来满足该业务的独特方面。然后，该公司可以选择将非核心增值业务的部分业务外包，并使用软件即服务 (SaaS) 应用程序来提供客户关系管理功能。</p>
<p>从很大程度上讲，该公司的格局可能会从头建立。主要关注点可能是它在一个持续可用的环境（绿场的概念）中以极少的宕机时间快速添加新功能的能力。该公司可能想根据无法预测的客户需求来实现灵活的伸缩（即扩展和精减）。它可能希望实现一种全天候的、高度可用的在线存在感。</p>
<p>微服务架构是该公司的许多格局的逻辑选择，如图 6所示。</p>
<p><img src="/uploads/wfwjg.png" alt="Paste_Image.png"></p>
<p>新应用程序可能位于单个微服务框架中，该框架提供了非功能性能力，比如可伸缩性、可用性和资源管理。您可能预料到低级集成问题很少，因为所有微服务组件和所涉及的 SaaS 应用程序都将使用常见的协议（比如 HTTP/JSON API）进行通信。SOA 公开宝贵的功能的一个关键目标是，为了它可以在整个企业中得到结合使用。在这个示例中，精心实现的 SOA 和微服务架构之间的界线已变得模糊。如果想象一下 SOA 的完美实现，它可能看起来和这个示例一样，但只有新公司能够创建这种性质的架构。</p>
<p>本文不会探讨 SOA “服务组件” 是否在大小上与微服务组件相当。微服务组件的粒度和它们的分组方式完全是另一个话题。</p>
<p>现在我们来考虑一个相反的示例，一家已经发展起来的大型公司，几十年来它已经建立了自己的 IT 格局。这个企业可能是一家传统的银行或保险公司，可能拥有数百或者甚至数千个重要应用程序是使用可追溯到数十年前的技术构建的。该企业内可能拥有严格的部门划分，比如医疗、养老金和一般保险，或者零售和投资银行。每个业务部门可能都拥有专门处理其核心业务的独立应用程序。这些部门还可能有一套应用程序，比如对于人力资源，其应用程序会尽可能共享。</p>
<p>该公司可能是通过并购竞争对手发展起来的。在该格局中，您会发现应用程序之间存在大量的数据重复。根据最初为客户服务的公司，客户帐户可能分散在许多系统中。同一个客户在多个系统中的关联性可能不是很直观。这些后端应用程序通常很难在内部进行更改。在此环境中，SOA 的一项艰巨任务就是将后端系统重新想象为对未来的业务需求更有用的某种东西。</p>
<p>集成挑战也很复杂。它可能需要集成工具（如 图 7 所示），使得人们在存在协议、传输和数据格式上的挑战的情况下，仍能访问来自后端应用程序的数据和功能。主要出于历史原因，这种集成做法通常被打上 “SOA” 的标签，尽管它仅关注一半的 SOA 挑战。它被标为 SOA 是因为集成是大多数 SOA 举措处理的第一个区域。在许多情况下，这是他们在可用资金范围内完成的全部工作。</p>
<p><img src="/uploads/wfwdxqy.png" alt="Paste_Image.png"></p>
<p>但是，公司需要使用 SOA 实现的另一个方面是，将数据和功能改造为更加以业务为中心的功能。他们需要确定如何满足移动等新渠道，这些渠道需要使用与传统应用程序完全不同的服务粒度。为了实现这些方面，公司需要提供当前系统中可能没有的响应能力、可用性和可伸缩性。必须编写应用程序，以一种特殊风格满足这些新渠道，这种风格支持快速的敏捷变更，提供了极高的可伸缩性，而且提供了卓越的可用性。</p>
<p>人们很容易看到对这些新应用程序使用微服务架构的吸引力。如 图 7 所示，大型企业中对微服务的初始使用专注于新的互动参与体系应用程序。SOA 概念可能被早期的以集成为中心的工作所影响。因此，微服务通常被视为不同于 SOA，它提供了更高的敏捷性、可伸缩性和响应能力，但在许多情况下，这些取决于 SOA 的集成阶段的基础工作。</p>
<p><strong>9 在未来将微服务、SOA 和 API 组合在一起</strong></p>
<p>从架构的角度讲，SOA 有 3 个关键元素：</p>
<p>深入集成使老化的系统能够公开其数据和功能，以便使用一个接口来发现这些数据和功能；</p>
<p>服务公开标准化并简化这些接口向更广泛的受众公开的方式；</p>
<p>服务组件将接口进一步组合到更宝贵的业务资产中；</p>
<p>这 3 种元素仍会存在于未来的架构中，但它们一定会分散在整个格局中，如图 8所示。</p>
<p><strong>9.1 深入集成</strong></p>
<p>一些系统仍需要集成中心所提供的深入集成功能，以便将它们的基础功能和数据公开为 API。其他系统可能能够在升级到新版本时直接提供 API。当 SOA 倾向于将深入集成功能整合到一个集中化功能中时，关键区别就会显现出来。更高级的工具和技术应支持集成，以便更频繁地与应用程序所有者进行联合，如 图 8 中的集成中心的位置所示。</p>
<p><img src="/uploads/zh.png" alt="Paste_Image.png"></p>
<p><strong>9.2 服务公开</strong></p>
<p>此外，所有系统只要想要保持关联，都需要提供 API。应用程序级 API 需要一个轻量型的控制层，如 图 8 中的 API 网关所示。这个控制层是来自 SOA 的服务公开概念的一种演化。它已变成更广泛、更分散化的 API 公开。</p>
<p>API 网关和管理功能可能是整个企业的一种通用资源。它是 “分散化的”，应用程序团队可以自行发布 API，同样也可以自行订阅他们所需的 API，而不再需要一个额外的团队。您可以在整个企业中以标准方式获得标准化的流量管理和监视、日志记录、审计和安全性机制，同时保留业务人员所需的敏捷性。这些相同的 API 网关也可用来帮助管理与业务合作伙伴和外部 SaaS 功能的交互。</p>
<p><strong>9.3 服务组件</strong></p>
<p>传统的、更加孤立的应用程序仍适合一些实现。但是，微服务提供了一种构建某些类型的应用程序的替代方法，提供了传统应用程序无法提供的敏捷性、可伸缩性和恢复能力。微服务应用程序在互动层最常见，这一层最需要它们的具体特征，支持创建新的特定于渠道的功能和面对互联网的 API。</p>
<p><strong>10 结束语</strong></p>
<p>对于 SOA 打算实现的目标，至少有两种不同的观点。SOA 与微服务架构之间的直接对比可能充满困难。SOA 的概念存在于现代架构中，但已通过多种方式发生了演变。集成工具、模式和标准也已发生演变，所以功能和数据更容易公开。服务公开已演变为 API，简化了公开、使用、管理，在某些情况下，还可以从业务功能中牟利。新应用程序架构（包括微服务架构）使得开发人员能够更密切地关注业务逻辑，不断将基础架构细节推送到他们所在的环境。这些开发方式的组合有助于以更敏捷的风格构建解决方案，有助于应用程序获得全新的弹性可伸缩性和容错水平。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2016/06/21/推荐一个mongdb管理工具/" itemprop="url">
                  推荐一个mongdb管理工具
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-06-21T13:53:53+08:00" content="2016-06-21">
              2016-06-21
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/21/推荐一个mongdb管理工具/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/21/推荐一个mongdb管理工具/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <pre><code>Robomongo 是一个基于 Shell 的跨平台开源 MongoDB 管理工具。嵌入了 JavaScript 引擎和 MongoDB mogo 。只要你会使用 mongo shell ，你就会使用 Robomongo。提供语法高亮、自动完成、差别视图等。
https://robomongo.org
</code></pre>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2016/06/21/spring-4-3新特性/" itemprop="url">
                  spring 4.3新特性
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-06-21T13:38:48+08:00" content="2016-06-21">
              2016-06-21
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/21/spring-4-3新特性/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/21/spring-4-3新特性/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>核心容器改进</p>
<p>   1.核心容器额外提供了更丰富的元数据来改进编程。<br>   2.默认 Java 8 的方法检测为 bean 属性的 getter/setter 方法。<br>   3.如果目标 bean 只定义了一个构造函数,则它无需要指定@Autowired注解<br>   4.@Configuration类支持构造函数注入。<br>   5.任何 SpEL 表达式用于指定@EventListener的 condition 引用到 bean（例如@beanName.method()）。<br>   6.组成注解现在可以用一个包含元注解中的数组属性的数组组件类型的元素来覆盖。例如，@RequestMapping的的String[] path 可以在组成注解用 String path 覆盖。<br>   7.@Scheduled和@Schedules现在是作为元注解用来通过属性覆盖来创建自定义的组成注解。<br>   8.@Scheduled适当支持任何范围内的 bean。<br>数据访问改进</p>
<p>   1.jdbc:initialize-database 和 jdbc:embedded-database 支持可配置的分离器被应用到每个脚本。</p>
<p>缓存改进</p>
<p>   1.Spring 4.3 允许在一个给定的 key 并发调用时实现要同步，使得相应的值只计算一次。这是一个可选的功能，通过设置@Cacheable的新的 sync 属性来启用。此功能引入了Cache接口的一个重大更改，即get(Object key, Callable<t> valueLoader)方法已添加。</t></p>
<p>Spring 4.3 还改进了缓存抽象如下：</p>
<p>   2.SpEL 表达式对于缓存相关的注解，现在可以引用 bean（即@beanName.method())）。<br>   3.ConcurrentMapCacheManager和ConcurrentMapCache现在通过一个新的storeByValue属性支持缓存实体的序列化。 @Cacheable，@CacheEvict，@CachePut和@Caching现在是作为元注解用来通过属性覆盖来创建自定义的组成注解。<br>JMS 改进</p>
<p>   1.@SendTo现在可以在类级别指定一个共同回复目标。<br>   2.@JmsListener 和 @JmsListeners现在是作为元注解用来通过属性覆盖来创建自定义的组成注解。<br>Web 改进</p>
<p>   1.内建支持 HTTP HEAD 和 HTTP OPTIONS.<br>   2.新的组合注解 @GetMapping, @PostMapping, @PutMapping, @DeleteMapping, 和 @PatchMapping 用于 @RequestMapping。<br>     详见 @RequestMapping 组合变种<br>   3.新的@RequestScope, @SessionScope, 和 @ApplicationScope用于 web 范围的组合注解<br>   4.Request scope, Session scope, 和 Application scope<br>   5.新的 @RestControllerAdvice 注解是 @ControllerAdvice 和 @ResponseBody 的语义结合<br>   6.@ResponseStatus现在在类级别被支持，并被所有方法继承<br>   7.新的 @SessionAttribute 注解用于访问 session 属性 (见例子)<br>   8.新的 @RequestAttribute 注解用于访问请求属性 (见例子)<br>   9.@ModelAttribute 允许通过 binding=false 来避免数据绑定(见引用)<br>   10.错误和自定义抛出，将被统一到 MVC 异常处理器中处理<br>   11.HTTP 消息转换编码一致处理，包括默认 UTF-8 用于多部分文本内容<br>   12.静态资源处理使用配置的ContentNegotiationManager用于媒体类型计算<br>   13.RestTemplate 和 AsyncRestTemplate 支持通过DefaultUriTemplateHandler 来实现严格的URI变量编码<br>   14.AsyncRestTemplate支持请求拦截</p>
<p>WebSocket 消息改进</p>
<p>   1.@SendTo和@SendToUser现在可以在类级被指定为共享共同的目的地。</p>
<p>测试改进</p>
<p>   1.为了支持 Spring TestContext Framework ，现在需要 JUnit 4.12 或者更高的版本<br>   2.新的SpringRunner 关联于 SpringJUnit4ClassRunner<br>   3.测试相关的注解，现在可以在接口上声明了。例如，基于 Java 8 的接口上使用测试接口<br>   4.空声明的 @ContextConfiguration 现在将会完全忽略，如果检测到默认的 XML 文件, Groovy 脚本, 或 @Configuration 类型<br>   5.@Transactional 测试方法不再需要public (如, 在 TestNG 和 JUnit 5)<br>   6.@BeforeTransaction 和 @AfterTransaction不再需要public，并且在 基于 Java 8 的接口的默认方法上声明<br>   7.在Spring TestContext Framework 的ApplicationContext的缓存现在有界为32默认最大规模和最近最少使用驱逐策略。最大的大小可以通过设置称为spring.test.context.cache.maxSize 一个 JVM 系统属性或 Spring 配置。<br>   8.ContextCustomizer API 用于自定义测试 ApplicationContext 在 bean 定义加载到上下文后但在上下文被刷新前。定制工具可以在全球范围由第三方进行注册，而无需要实现一个自定义的 ContextLoader。<br>   9.@Sql 和 @SqlGroup 现在作为元注解通过覆盖属性来创建自定义组合注解10.<br>   10.ReflectionTestUtils现在在 set 或 get 一个字段时，会自动解开代理。<br>   11.服务器端的 Spring MVC 测试支持具有多个值的响应头。<br>   12.服务器端的 Spring MVC 测试解析表单数据的请求内容和填充请求参数。<br>   13.服务器端的 Spring MVC 测试支持 mock 式的断言来调用处理程序方法。<br>   14.客户端 REST 测试支持允许指定多少次预期的请求以及期望的声明顺序是否应该被忽略（参见15.6.3，“客户端REST测试”）。<br>   15.客户端 REST 测试支持请求主体表单数据的预期。</p>
<p>支持新的类库和服务器</p>
<p>   1.Hibernate ORM 5.2 (同样很好的支持 4.2/4.3 和 5.0/5.1，不推荐 3.6 )<br>   2.Jackson 2.8 (在Spring 4.3，最低至 Jackson 2.6+ )<br>   3.OkHttp 3.x (仍然并行支持 OkHttp 2.x)<br>   4.Netty 4.1<br>   5.Undertow 1.4<br>   6.Tomcat 8.5.2 以及 9.0 M6</p>
<p>参考引用<br>中文的 《Spring Framework 4.x参考文档》</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2016/04/29/业务层面缓存穿透的方案/" itemprop="url">
                  业务层面缓存穿透的方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-04-29T14:29:10+08:00" content="2016-04-29">
              2016-04-29
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/29/业务层面缓存穿透的方案/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/29/业务层面缓存穿透的方案/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>网上有一些关于缓存穿透和缓存雪崩的解决方案，无非是：</p>
<pre><code>1.如果查询数据为null，则把null进行缓存

2.使用布隆过滤器
</code></pre><p>先来说说缓存穿透的概念：我们在项目中使用缓存通常都是APP先检查缓存中是否存在，如果存在直接返回缓存内容，如果不存在就直接查询数据库然后再缓存查询结果返回。这个时候如果我们查询的某一个数据在缓存中一直不存在，就会造成每一次请求都查询DB，这样缓存就失去了意义，在流量大时，可能DB就挂掉了。</p>
<p>再来讲讲我们的业务场景：</p>
<pre><code> 1.通常我们是首页，或是统计页，用户请求较多，首页进入系统必定会加载，统计页（针对一些准实时的统计结果）查询的SQL或是结果比较复杂。

 2.时效性一般，基本上小时级别

 3.数据量较大，一般是亿级或是千万级别

 4.业务逻辑比较复杂，可能需要进行各种表的关联

 5.如果请求过多，有可能数据库奔溃，即使在进行分库分表之后还是有可能占用一大部分的数据库IO和CPU资源

 6.统计的维度较多，每个用户请求的维度可能是不一样的。

 针对上述情况我们一般的做法，就是加一层缓存，请求过来先去访问缓存，可以使用memcached或是redis，如果缓存不存在或是缓存失效的情况下，再去load DB。大部分的情况下，这是非常好的，但是某一天如果你需要重启缓存，或是缓存在某一时刻失效很大一部分，这就会导致我们之前所说的缓存穿透。

ok，来说下我们在缓存穿透的优化吧：先来看个架构图，在来解释
</code></pre><p><img src="/uploads/缓存穿透.png" alt="Paste_Image.png"></p>
<pre><code>1.更具业务统计的维度或是场景，建立一张以JSON格式为模板的表

2.通过调度平台，定时的把任务统计完成并保存至模板表中和缓存集群中

3.不断对2进行轮询，保持数据的热度

4.用户请求过来，先访问我们的缓存，一旦缓存失效或是重启，直接从数据库模板表中获取最新的热度数据并缓存，这样我们就能有效的减轻数据库的压力。

5.这也是一种缓存预热的方案
</code></pre><p> 技术交流：534368042</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


 </div>

        

        
      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/uploads/avatar.jpg" alt="yl.lu" itemprop="image"/>
          <p class="site-author-name" itemprop="name">yl.lu</p>
        </div>
        <p class="site-description motion-element" itemprop="description">记录生活点滴</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">25</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/luyulong" target="_blank">
                  <i class="fa fa-github"></i> GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/" target="_blank">
                  <i class="fa fa-新浪微博"></i> 新浪微博
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yl.lu</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>
<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"luyulong"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     
     
  	<script src="/js/ua-parser.min.js"></script>
  	<script src="/js/hook-duoshuo.js"></script>
  


    
  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }

      motionIntegrator.bootstrap();
    });
  </script>

  
  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
